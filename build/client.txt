#client.py
import os
import sys
import asyncio
import packet
import websockets
import json
import base64
from datetime import datetime
from io import BytesIO
from PIL import Image

from PyQt5.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout, QLineEdit,
    QPushButton, QLabel, QDialog, QDialogButtonBox, QScrollArea, QFrame,
    QSizePolicy, QFileDialog, QTextEdit, QComboBox, QTextBrowser, QBoxLayout, QListWidget, QListWidgetItem
)
from PyQt5.QtGui import QFont, QFontDatabase, QPixmap, QTextOption
from PyQt5.QtCore import Qt, QTimer, QPoint, QCoreApplication
from qasync import QEventLoop, asyncSlot

from PyQt5.QtCore import Qt, QTimer, QPoint, QPropertyAnimation, QEasingCurve
from win32cryptcon import szOID_NETSCAPE_DATA_TYPE


def resource_path(relative_path):
    """
    PyInstallerë¡œ íŒ¨í‚¤ì§•í•œ ì‹¤í–‰ íŒŒì¼ì—ì„œë„ ë¦¬ì†ŒìŠ¤ íŒŒì¼ ê²½ë¡œë¥¼ ì œëŒ€ë¡œ ì°¸ì¡°í•˜ê¸° ìœ„í•´ ì‚¬ìš©
    - ê°œë°œ í™˜ê²½: í˜„ì¬ ë””ë ‰í† ë¦¬
    - ë°°í¬ í™˜ê²½: _MEIPASS ì„ì‹œ ë””ë ‰í† ë¦¬
    """
    try:
        base_path = sys._MEIPASS  # PyInstaller ì‹¤í–‰ ì‹œ ìƒì„±ë˜ëŠ” ì„ì‹œ í´ë”
    except AttributeError:
        base_path = os.path.abspath(".")

    return os.path.join(base_path, relative_path)

# ì‹¤í–‰ ì¤‘ì¸ íŒŒì¼ ìœ„ì¹˜ ê¸°ì¤€ìœ¼ë¡œ ìºì‹œ ì €ì¥
CACHE_FILE = os.path.join(
    os.path.dirname(sys.executable if getattr(sys, 'frozen', False) else __file__),
    "users_cache.json"
)

def load_user_cache():
    if not os.path.exists(CACHE_FILE):
        return {}
    try:
        with open(CACHE_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception as e:
        print(f"ìºì‹œ ë¡œë”© ì‹¤íŒ¨: {e}")
        return {}

def save_user_cache(nickname, image_path):
    try:
        users = load_user_cache()
        users[nickname] = image_path
        with open(CACHE_FILE, "w", encoding="utf-8") as f:
            json.dump(users, f, indent=2, ensure_ascii=False)
    except Exception as e:
        print(f" ìºì‹œ ì €ì¥ ì‹¤íŒ¨: {e}")


def resize_image_to_base64(image_path, size=(128, 128)):
    img = Image.open(image_path)
    img = img.resize(size)
    buffer = BytesIO()
    img.save(buffer, format="PNG")
    return base64.b64encode(buffer.getvalue()).decode("utf-8")


class NicknameDialog(QDialog):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("ë‹‰ë„¤ì„ ì„ íƒ ë˜ëŠ” ì…ë ¥")
        self.setFixedSize(300, 200)
        self.image_path = None
        self.cached_users = load_user_cache()

        layout = QVBoxLayout()
        self.label = QLabel("ë‹‰ë„¤ì„ì„ ì„ íƒí•˜ê±°ë‚˜ ìƒˆë¡œ ì…ë ¥í•˜ì„¸ìš”")

        # ë‹‰ë„¤ì„ ì„ íƒ ì½¤ë³´ë°•ìŠ¤ + ì…ë ¥
        self.nickname_combo = QComboBox()
        self.nickname_combo.setEditable(True)
        self.nickname_combo.addItems(self.cached_users.keys())
        self.nickname_combo.setPlaceholderText("ì˜ˆ: ë‹¤ë‹ˆ")

        self.nickname_combo.currentIndexChanged.connect(self.load_selected_user)

        self.image_button = QPushButton("í”„ë¡œí•„ ì´ë¯¸ì§€ ì„ íƒ")
        self.image_button.clicked.connect(self.select_image)

        buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)

        layout.addWidget(self.label)
        layout.addWidget(self.nickname_combo)
        layout.addWidget(self.image_button)
        layout.addWidget(buttons)
        self.setLayout(layout)


        """
        layout = QVBoxLayout()
        self.label = QLabel("ë‹‰ë„¤ì„ì„ ì…ë ¥í•˜ì„¸ìš”")
        self.input = QLineEdit()
        self.input.setPlaceholderText("ì˜ˆ: í™ê¸¸ë™")
        self.image_button = QPushButton("í”„ë¡œí•„ ì´ë¯¸ì§€ ì„ íƒ")
        self.image_button.clicked.connect(self.select_image)

        buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)

        layout.addWidget(self.label)
        layout.addWidget(self.input)
        layout.addWidget(self.image_button)
        layout.addWidget(buttons)
        self.setLayout(layout)
        """
        self.setStyleSheet("""
            QLabel {
                font-size: 13px;
                color: #333;
            }

            QLineEdit {
                background-color: #f9f9f9;
                border: 1px solid #ccc;
                border-radius: 6px;
                padding: 5px;
            }

            QPushButton {
                background-color: #FFAE0F;
                color: white;
                border: none;
                padding: 8px 14px;
                border-radius: 6px;
                font-size: 13px;
            }

            QPushButton:hover {
                background-color: #EE9F05;
            }

            QDialogButtonBox QPushButton {
                background-color: white;
                border: 1px solid #ccc;
                border-radius: 6px;
                padding: 6px 12px;
                color: #333;
                font-size: 13px;
            }

            QDialogButtonBox QPushButton:hover {
                background-color: #f2f2f2;
                border: 1px solid #bbb;
            }
        """)

    def load_selected_user(self, index):
        nickname = self.nickname_combo.currentText()
        if nickname in self.cached_users:
            self.image_path = self.cached_users[nickname]
            self.image_button.setText("ìë™ ì„ íƒë¨")



    def select_image(self):
        file_name, _ = QFileDialog.getOpenFileName(self, "ì´ë¯¸ì§€ ì„ íƒ", "", "Images (*.png *.jpg *.jpeg)")
        if file_name:
            self.image_path = file_name
            self.image_button.setText("âœ… ì„ íƒë¨")

    def get_nickname_and_image(self):
        if self.exec_() == QDialog.Accepted:
            nickname = self.nickname_combo.currentText().strip()
            if nickname and self.image_path:
                save_user_cache(nickname, self.image_path)
            return nickname, self.image_path
        return None, None

class PopupNotification(QWidget):
    def __init__(self, title: str, message: str, parent=None):
        super().__init__(parent)
        self.setWindowFlags(Qt.FramelessWindowHint | Qt.Tool | Qt.WindowStaysOnTopHint)
        self.setAttribute(Qt.WA_TranslucentBackground)
        self.setFixedSize(300, 80)

        self.label = QLabel(self)
        self.label.setFixedSize(280, 60)
        self.label.setWordWrap(True)
        self.label.setAlignment(Qt.AlignLeft | Qt.AlignTop)

        self.label.setTextInteractionFlags(Qt.NoTextInteraction)

        self.label.setText(f"""
            <span style="color:#FF9500; font-weight:500;">{title}</span><br>
            <span style="color:#333;">{message}</span>
        """)

        self.label.setStyleSheet("""
            QLabel {
                background-color: white;
                border-radius: 10px;
                padding: 10px;
                border: 1px solid #ccc;
            }
        """)

        screen = QApplication.primaryScreen().geometry()
        x = screen.width() - self.width() - 20
        y = screen.height() - self.height() - 60
        self.move(QPoint(x, y))

        self.setWindowOpacity(0.0)
        self.fade_in = QPropertyAnimation(self, b"windowOpacity")
        self.fade_in.setDuration(300)
        self.fade_in.setStartValue(0.0)
        self.fade_in.setEndValue(1.0)
        self.fade_in.start()

        QTimer.singleShot(2500, self.close)

class ChatClient(QWidget):
    def dragEnterEvent(self, event):
        if event.mimeData().hasUrls():
            event.acceptProposedAction()

    def dropEvent(self, event):
        for url in event.mimeData().urls():
            file_path = url.toLocalFile()
            if os.path.isfile(file_path):
                asyncio.create_task(self._send_file_task(file_path))

    def __init__(self):
        super().__init__()
        self.setWindowTitle("âœ¨ ë‚´ë¶€ ë©”ì‹ ì €")
        self.resize(420, 550)
        self.setObjectName("MainWindow")
        self.setAcceptDrops(True)  # â† ë“œë˜ê·¸ì•¤ë“œë¡­ í—ˆìš©

        self.server_url = "ws://192.168.1.11:30006/ws/"

        self.message_map = {}  # reply_id â†’ {"bubble": QLabel, "frame": QFrame}
        self.thinking_timers = {}  # reply_id â†’ QTimer

        self.setStyleSheet("""
            QWidget#MainWindow {
                background-color: #f5f5f5;
                border-radius: 15px;
            }
        """)

        self.profile_image = None
        self.profiles = {}

        self.image_history = []  # base64 ë””ì½”ë”©ëœ QPixmap ë¦¬ìŠ¤íŠ¸
        self.current_image_index = 0  # í˜„ì¬ ë¯¸ë¦¬ë³´ê¸° ì¸ë±ìŠ¤

        nickname_dialog = NicknameDialog()
        self.username, image_path = nickname_dialog.get_nickname_and_image()
        if not self.username:
            sys.exit()

        if image_path:
            self.profile_image = resize_image_to_base64(image_path)

        self.websocket = None
        self.server_url = "ws://192.168.1.11:30006/ws/"

        font_path = resource_path("fonts/NanumSquareRoundR.ttf")
        if os.path.exists(font_path):
            QFontDatabase.addApplicationFont(font_path)
            self.setFont(QFont("NanumSquareRound", 10))
        else:
            self.setFont(QFont("Arial", 10))

        self.layout = QVBoxLayout()

        self.user_list_label = QLabel("ì ‘ì† ì¤‘: ", self)
        self.user_list_label.setStyleSheet("""
            QLabel {
                background-color: #ffffff;
                padding: 6px;
                font-size: 12px;
                color: #333;
                border-radius: 10px;
                border: 1px solid #ddd;
                margin: 0;
            }
        """)
        self.layout.addWidget(self.user_list_label)
        self.userlist = QListWidget(self)

        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_area.setStyleSheet("""
            QScrollArea {
                border: none;
                background-color: f5f5f5;
            }
        """)

        self.scroll_content = QWidget()
        self.chat_layout = QVBoxLayout(self.scroll_content)
        self.chat_layout.setSpacing(0)
        self.chat_layout.addStretch(1)
        self.scroll_area.setWidget(self.scroll_content)
        self.layout.addWidget(self.scroll_area)

        input_layout = QHBoxLayout()
        self.file_button = QPushButton("ğŸ“¤")
        self.file_button.setFixedSize(40, 30) 
        self.file_button.setStyleSheet("""
            QPushButton {
                background-color: #ffffff;
                border: 1px solid #ddd;
                border-radius: 8px;
                font-size: 18px;
            }
            QPushButton:hover {
                background-color: #f2f2f2;
                border: 1px solid #bbb;
            }
            QPushButton:pressed {
                background-color: #e6e6e6;
                border: 1px solid #aaa;
            }
        """)
        self.file_button.clicked.connect(self.send_file)

        self.input_line = QLineEdit()
        self.input_line.setPlaceholderText("ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš”.")
        self.input_line.setStyleSheet("""
            QLineEdit {
                background-color: white;
                border-radius: 10px;
                padding: 6px;
                font-size: 14px;
                border: 1px solid #ccc;
                margin-right: 10px;
            }
        """)

        self.send_button = QPushButton("ì „ì†¡")
        self.send_button.setStyleSheet("""
            QPushButton {
                background-color: #FFAE0F;
                border-radius: 10px;
                padding: 10px 20px;
                font-size: 14px;
                color: white;
                border: none;
            }
            QPushButton:hover {
                background-color: #EE9F05;
            }
        """)

        input_layout.addWidget(self.file_button) 
        input_layout.addWidget(self.input_line)
        input_layout.addWidget(self.send_button)

        self.layout.addLayout(input_layout)
        self.setLayout(self.layout)

        self.send_button.clicked.connect(self.send_message)
        self.input_line.returnPressed.connect(self.send_message)

        """ë¡œë”© ë¬¸êµ¬ìš© QLABEL ì¶”ê°€"""
        self.loading_label = QLabel("ğŸ’¬ ì±„íŒ… ê¸°ë¡ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...")
        self.loading_label.setAlignment(Qt.AlignCenter)
        self.loading_label.setStyleSheet("color: gray; font-size: 12px; margin: 10px;")
        self.chat_layout.insertWidget(0, self.loading_label)
        self.loading_label.hide()

        # ì½ì€ ì‹œì  ë°˜ì˜ ìœ„í•œ ìƒíƒœ ë³€ìˆ˜
        self.history_loaded = False
        self.separator_shown = False

        # read_message_count ì €ì¥ ë³€ìˆ˜ ì¶”ê°€
        #self.read_message_count = 0

        self.last_received_message_id = None  # âœ… ë©”ì‹œì§€ ID ê¸°ë°˜ ì½ì€ ìœ„ì¹˜ ì´ˆê¸°í™”

        self.private_chats = {} # ê°œì¸ ì±„íŒ…ë°© ì €ì¥ìš© ë”•ì…”ë„ˆë¦¬ ì´ˆê¸°í™”

        # ìœ ì € ë¦¬ìŠ¤íŠ¸ ê°ì²´ ì´ë¦„ ìˆ˜ì •
        self.user_list = QListWidget(self)
        self.user_list.itemDoubleClicked.connect(self.open_private_chat)    # ë”ë¸”í´ë¦­í•˜ì—¬ ê°œì¸ ì±„íŒ…ë°© ê°œì„¤
        self.layout.addWidget(self.user_list)   # ìœ ì € ëª©ë¡ë„ ë ˆì´ì•„ì›ƒì— í¬í•¨

    async def check_nickname_available(self,nickname):
        async with websockets.connect(self.server_url) as ws:
            await ws.send(json.dumps({"type": "validate", "nickname": nickname}))
            response = await ws.recv()
            result = json.loads(response)
            return result.get("available", False)


    def set_loading_state(self, loading: bool):
        if loading:
            print("ë¡œë”© ì¤‘ì…ë‹ˆë‹¤..")
            self.loading_label.show()

        else:
            print("ë¡œë”©ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")
            self.loading_label.hide()

    async def connect(self):
        try:
            self.websocket = await websockets.connect(
                self.server_url + self.username,
                max_size=None  # â† ì œí•œ í•´ì œ
            )
            await self.receive_messages()




        except Exception as e:
            self.add_message(f"âŒ ì—°ê²° ì‹¤íŒ¨: {e}", is_system=True)

    @asyncSlot()
    async def send_message(self):
        message = self.input_line.text().strip()
        if message and self.websocket:
            packet = {
                "sender": self.username,
                "message": message,
                "profile": self.profile_image
            }

            asyncio.create_task(self._safe_send(json.dumps(packet)))

            self.add_message(message, from_self=True, profile=self.profile_image)
            self.input_line.clear()

    # WebSocket ì „ì†¡ì„ í•œ Task ì•ˆì—ì„œë§Œ ì²˜ë¦¬í•˜ë„ë¡ ë³´ì¥
    async def _safe_send(self, data: str):
        try:
            await self.websocket.send(data)
        except Exception as e:
            self.add_message(f"âŒ ì „ì†¡ ì˜¤ë¥˜: {e}")

    @asyncSlot()
    async def send_file(self):
        file_paths, _ = QFileDialog.getOpenFileNames(
            self, "ì´ë¯¸ì§€ ì„ íƒ", "", "Images (*.png *.jpg *.jpeg *.gif)")

        for file_path in file_paths:
            if file_path:
                await self._send_file_task(file_path)

    async def _send_file_task(self, file_path):
        try:
            with open(file_path, "rb") as f:
                data = base64.b64encode(f.read()).decode("utf-8")

            filename = os.path.basename(file_path)
            ext = os.path.splitext(filename)[1].lower()

            packet = {
                "sender": self.username,
                "message": f"[íŒŒì¼] {filename}",
                "profile": self.profile_image,
                "file": {
                    "name": filename,
                    "data": data,
                    "type": ext 
                }
            }

            await self._safe_send(json.dumps(packet))

            self.add_file_message(filename, data, ext, from_self=True, profile=self.profile_image)

        except Exception as e:
            self.add_message(f"âŒ íŒŒì¼ ì „ì†¡ ì‹¤íŒ¨: {e}")

    async def receive_messages(self):

        try:
            async for raw in self.websocket:
                packet = json.loads(raw)

                """ê°œì¸í†¡ ë¶„ê¸° ì²˜ë¦¬"""
                if packet["type"] == "private_room":
                    sender = packet["sender"]
                    receiver = packet["receiver"]
                    msg = packet["message"]

                    # í˜„ì¬ ë‚´ê°€ ìˆ˜ì‹ ì or ë°œì‹ ìì¸ ê²½ìš°ë§Œ í•´ë‹¹ ì°½ ë„ìš°ê¸°
                    if receiver == self.username or sender == self.username:
                        partner = sender if sender != self.username else receiver
                        if partner not in self.private_chats:
                            self.open_private_chat(QListWidgetItem(partner))
                        self.private_chats[partner].receive_message(sender, msg)








                if "sender" in packet and "message" in packet:
                    sender = packet["sender"]
                    message = packet["message"]
                    profile = packet.get("profile")
                    is_me = (sender == self.username)

                    # íˆìŠ¤í† ë¦¬ ì´í›„, ì²˜ìŒ ë„ì°©í•œ íƒ€ì¸ ë©”ì„¸ì§€ì— êµ¬ë¶„ì„  ì‚½ì…
                    if self.history_loaded and not is_me and not self.separator_shown:
                        self.add_separator()
                        self.separator_shown = True

                    file_info = packet.get("file")
                    if file_info:
                        if sender == self.username:
                            continue

                        self.add_file_message(
                            filename=file_info["name"],
                            data_b64=file_info["data"],
                            ext=os.path.splitext(file_info["name"])[1].lower(),
                            from_self=False,
                            profile=profile,
                            sender_name=sender,  #ì—¬ê¸° ì¶”ê°€

                        )
                        continue

                    self.profiles[sender] = profile
                    if sender != self.username:
                        self.add_message(
                            f"{sender}: {message}",
                            from_self=False,
                            profile=profile,
                            is_system = False
                        )
                        popup = PopupNotification(sender, message)
                        popup.show()

                elif "users" in packet:
                    self.update_user_list(packet["users"])

                # typeì— íˆìŠ¤í† ë¦¬ ìˆì„ ì‹œ, ì´ì „ ëŒ€í™” ë¶ˆëŸ¬ì˜´(ë‹¹ì¼ í•œì •)
                elif packet.get("type") == "history":
                    self.set_loading_state(True)  # â¬…ï¸ ë¡œë”© ì‹œì‘ í‘œì‹œ
                    self.last_read_id = packet.get("last_read_id")
                    print("last_read_id =",self.last_read_id)

                    #self.read_message_count = packet.get("read_count", 0)  # âœ… ì„œë²„ ì‘ë‹µ ê¸°ì¤€

                    for i, msg in enumerate(packet["messages"]):
                        message_id = msg["id"]
                        is_me = (msg["sender"] == self.username)

                        self.add_message(
                            text=f"{msg['sender']}: {msg['message']}",
                            from_self=is_me,
                            profile=msg.get("profile"),
                            is_system=False
                        )

                        # âœ… ë§ˆì§€ë§‰ ì½ì€ ë©”ì‹œì§€ IDì™€ ì¼ì¹˜í•˜ë©´ êµ¬ë¶„ì„  ì‚½ì…
                        print("last_read_id =",self.last_read_id)

                        if self.last_read_id is not None and message_id == self.last_read_id:
                            print(f"ğŸ‘ êµ¬ë¶„ì„  ì‚½ì… ìœ„ì¹˜: {i}")
                            self.add_separator()
                        """
                        if i == len(packet["messages"]) - 1:
                            QApplication.processEvents()  # ê°•ì œë¡œ UI ì—…ë°ì´íŠ¸
                            QTimer.singleShot(150, self.scroll_to_bottom)  # ë”± í•œ ë²ˆë§Œ ìŠ¤í¬ë¡¤
                            QTimer.singleShot(300, self.scroll_to_bottom)
                        """
                    # ìƒíƒœ ì´ˆê¸°í™”
                    self.history_loaded = True
                    self.separator_shown = False
                    self.set_loading_state(False)  # â¬…ï¸ ë¡œë”© ë

                    #ìµœí•˜ë‹¨ ë§ê³ , êµ¬ë¶„ì„  ìœ„ì¹˜ë¡œ ì´ë™
                    QTimer.singleShot(1000, self.scroll_to_separator)

                # ë©”ì‹œì§€ ìˆ˜ì‹ í•  ë•Œë§ˆë‹¤ ë§ˆì§€ë§‰ ID ì €ì¥
                # ì•ˆì „í•˜ê²Œ ì ‘ê·¼í•˜ê¸°
                self.last_received_message_id = packet.get("id", self.last_received_message_id)

        except Exception as e:
            self.add_message(f"âŒ ì—°ê²° ì¢…ë£Œ: {e}", is_system=True)

    """ ì˜¤ë²„ë¼ì´ë“œí•´ì„œ ì¢…ë£Œ ì§ì „ì— ì½ì€ ë©”ì‹œì§€ ìˆ˜ë¥¼ ì„œë²„ì— ì „ì†¡"""
    def closeEvent(self, event):
        async def send_and_exit():
            if self.websocket and self.last_received_message_id:
                try:
                    await self._safe_send(json.dumps({
                        "type": "update_read_id",
                        "username": self.username,
                        "message_id": self.last_received_message_id
                    }))
                    print("ğŸ“¤ ë§ˆì§€ë§‰ ì½ì€ ID ì „ì†¡ ì™„ë£Œ")
                    await asyncio.sleep(0.2)  # â³ ì„œë²„ì— ì „ë‹¬ë  ì‹œê°„ì„ ì¤Œ
                except Exception as e:
                    print(f"âŒ ì „ì†¡ ì‹¤íŒ¨: {e}")
            QCoreApplication.quit()  # ì¢…ë£Œ

        asyncio.ensure_future(send_and_exit())  # ì´ë²¤íŠ¸ ë£¨í”„ì— ë“±ë¡
        event.ignore()  # ë°”ë¡œ ì¢…ë£Œí•˜ì§€ ì•ŠìŒ

    
    
    """êµ¬ë¶„ì„  í•¨ìˆ˜ ì •ì˜"""
    def add_separator(self):
        print("âœ… êµ¬ë¶„ì„  ì¶”ê°€ë¨")
        separator = QLabel("ğŸ”½ ì´í›„ ìƒˆ ë©”ì‹œì§€")
        separator.setAlignment(Qt.AlignCenter)
        separator.setStyleSheet("color: #999; font-size: 11px; margin: 8px;")
        self.chat_layout.insertWidget(self.chat_layout.count() - 1, separator)
        
        self.separator_label = separator   # ë‚˜ì¤‘ì— ìŠ¤í¬ë¡¤ ìœ„ì¹˜ í™•ì¸ìš©ìœ¼ë¡œ ì €ì¥
        print("âœ… separator_label ì„¤ì • ì™„ë£Œ")

        # ì‚½ì… í›„ ë Œë”ë§ ì™„ë£Œë˜ë©´ ìŠ¤í¬ë¡¤ ì´ë™
        QTimer.singleShot(2000, self.scroll_to_separator)

    def add_message(self, text, reply_id=None, from_self=False, is_system=False, profile=None):
        time_str = datetime.now().strftime("%H:%M")

        # ì´ë¦„: ë©”ì‹œì§€ í˜•ì‹ì¼ ê²½ìš°, ë¶„ë¦¬
        if not from_self and not is_system and ":" in text:
            sender, message = text.split(":", 1)
        else:
            message = text


        """ gpt ë¡œë”© í›„ ë§í’ì„  ë‚´ìš© êµì²´"""
        # ğŸ‘‰ reply_idê°€ ìˆì„ ê²½ìš° ê¸°ì¡´ ë§í’ì„ ì„ ì°¾ì•„ ì—…ë°ì´íŠ¸ë§Œ ìˆ˜í–‰
        if reply_id and hasattr(self, "message_map") and reply_id in self.message_map:
            # ê¸°ì¡´ QLabel ê°€ì ¸ì™€ì„œ í…ìŠ¤íŠ¸ë§Œ êµì²´

            bundle = self.message_map[reply_id]
            bubble = bundle["bubble"]

            bubble.setText(message.strip()) # í…ìŠ¤íŠ¸ êµì²´

            # íƒ€ì´ë¨¸ ì¤‘ë‹¨
            if reply_id in self.thinking_timers:
                self.thinking_timers[reply_id].stop()
                del self.thinking_timers[reply_id]

            return  # ì—…ë°ì´íŠ¸ë§Œ í•˜ê³  ë§í’ì„  ìƒˆë¡œ ì¶”ê°€ëŠ” í•˜ì§€ ì•ŠìŒ

        # ğŸ‘‰ reply_idê°€ ì—†ê±°ë‚˜ ì‹ ê·œ ë©”ì‹œì§€ì¼ ê²½ìš° ìƒˆ ë§í’ì„  ìƒì„±
        bubble = QLabel(message.strip())
        bubble.setTextInteractionFlags(Qt.TextSelectableByMouse) 
        bubble.setWordWrap(True)
        bubble.setMaximumWidth(340)
        bubble.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)
        bubble.setStyleSheet(f"""
            background-color: {'#FFCF71' if from_self else '#ffffff'};
            padding: 8px 8px;
            border-radius: 14px;
            color: black;
        """)
        bubble.adjustSize()

        # ì‹œê°„ ë¼ë²¨
        time_label = QLabel(time_str)
        time_label.setStyleSheet("color: gray; font-size: 10px; margin: 1px;")

        # ìƒëŒ€ë°© ì´ë¦„ ë¼ë²¨ (ë³¸ì¸ ë©”ì‹œì§€ëŠ” í‘œì‹œ ì•ˆ í•¨)
        if not from_self and not is_system:
            name_label = QLabel(sender)
            name_label.setStyleSheet("color: black; font-size: 11px; margin-bottom: 0;")
            layout_name = QVBoxLayout()
            layout_name.setContentsMargins(10, 0, 10, 0)
            layout_name.addWidget(name_label, alignment=Qt.AlignLeft)
            self.chat_layout.insertLayout(self.chat_layout.count() - 1, layout_name)

        # ë§í’ì„  + ì‹œê°„ ë¬¶ê¸°
        bubble_container = QVBoxLayout()
        bubble_container.addWidget(bubble)
        bubble_container.addWidget(time_label, alignment=Qt.AlignRight if from_self else Qt.AlignLeft)

        profile_label = QLabel()
        profile_label.setFixedSize(36, 36)
        if profile:
            try:
                # base64 ê¸¸ì´ ë³´ì •
                missing_padding = len(profile) % 4
                if missing_padding:
                    profile += '=' * (4 - missing_padding)

                pixmap = QPixmap()
                pixmap.loadFromData(base64.b64decode(profile))
            except Exception as e:
                print(f"âŒ í”„ë¡œí•„ ì´ë¯¸ì§€ ë””ì½”ë”© ì‹¤íŒ¨: {e}")
                default_path = os.path.join(os.path.dirname(__file__), "images/face.png")
                pixmap = QPixmap(default_path)

        else:
            DEFAULT_PROFILE_PATH = os.path.join(os.path.dirname(__file__), "images/face.png")
            pixmap = QPixmap(DEFAULT_PROFILE_PATH)
            if pixmap.isNull():
                print("âŒ QPixmap failed to load face.png at", DEFAULT_PROFILE_PATH)

        profile_label.setPixmap(pixmap.scaled(36, 36, Qt.KeepAspectRatio, Qt.SmoothTransformation))

        # ë§í’ì„  í”„ë ˆì„ êµ¬ì„±
        bubble_frame = QFrame()
        layout = QHBoxLayout(bubble_frame)
        layout.setContentsMargins(10, 4, 10, 4)

        if from_self:
            layout.addStretch()
            layout.addLayout(bubble_container)
            layout.addWidget(profile_label)
        else:
            layout.addWidget(profile_label)
            layout.addLayout(bubble_container)
            layout.addStretch()

        # ë§í’ì„  ì¶”ê°€
        self.chat_layout.insertWidget(self.chat_layout.count() - 1, bubble_frame)

        # reply_idê°€ ìˆìœ¼ë©´ í•´ë‹¹ ë§í’ì„ ì„ ê¸°ì–µí•´ ë‘  (GPT ì‘ë‹µ ì‹œ ì—…ë°ì´íŠ¸ìš©)
        if reply_id:
            if not hasattr(self, "message_map"):
                self.mesage_map = {}    # ìµœì´ˆ ìƒì„±
            self.message_map[reply_id] = {
                "bubble": bubble,
                "frame": bubble_frame
            }
            self.start_thinking_animation(reply_id)  # ğŸ‘ˆ ì—¬ê¸°ì— ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘ í˜¸ì¶œ!
        # ìŠ¤í¬ë¡¤ ë§¨ ì•„ë˜ë¡œ
        QTimer.singleShot(10, self.scroll_to_bottom)

    """ê¹œë¹¡ì´ëŠ” í•¨ìˆ˜ ì¶”ê°€"""
    def start_thinking_animation(self, reply_id):
        if reply_id not in self.message_map:
            return

        bubble = self.message_map[reply_id]["bubble"]
        self.thinking_dots = 0 # ì  ê°œìˆ˜ ì´ˆê¸°í™”

        def update_text():
            self._thinking_dots = (self.thinking_dots + 1) % 4
            dots = "." * self._thinking_dots
            bubble.setText(f"â³ ë‹µë³€ì„ ìƒì„± ì¤‘ì…ë‹ˆë‹¤{dots}")

        timer = QTimer(self)
        timer.timeout.connect(update_text)
        timer.start(500)
        self.thinking_timers[reply_id] = timer



    def add_file_message(self, filename, data_b64, ext, from_self=False, profile=None, sender_name=None):
        time_str = datetime.now().strftime("%H:%M")
        is_image = ext in [".png", ".jpg", ".jpeg", ".gif"]

        # ì´ë¦„ ë¼ë²¨ ì²˜ë¦¬ (ë³¸ì¸ì´ ë³´ë‚¸ ê²Œ ì•„ë‹ ë•Œë§Œ, ê·¸ë¦¬ê³  sender_nameì´ ì¡´ì¬í•  ë•Œë§Œ)
        if not from_self and sender_name:
            name_label = QLabel(sender_name)
            name_label.setStyleSheet("color: black; font-size: 11px; margin-bottom: 0;")
            layout_name = QVBoxLayout()
            layout_name.setContentsMargins(10, 0, 10, 0)
            layout_name.addWidget(name_label, alignment=Qt.AlignLeft)
            self.chat_layout.insertLayout(self.chat_layout.count() - 1, layout_name)

        profile_label = QLabel()
        profile_label.setFixedSize(36, 36)
        if profile:
            pixmap = QPixmap()
            pixmap.loadFromData(base64.b64decode(profile))
        else:
            default = QPixmap(os.path.join(os.path.dirname(__file__), "images/face.png"))
            pixmap = default
        profile_label.setPixmap(pixmap.scaled(36, 36, Qt.KeepAspectRatio, Qt.SmoothTransformation))

        content_widget = QWidget()
        layout = QVBoxLayout(content_widget)
        layout.setContentsMargins(10, 4, 10, 4)

        if is_image:
            image_container = QFrame()
            image_container.setStyleSheet("border: none;")
            image_layout = QVBoxLayout(image_container)
            image_layout.setContentsMargins(0, 0, 0, 0)

            image_label = QLabel()
            pixmap = QPixmap()
            pixmap.loadFromData(base64.b64decode(data_b64))

            # ì´ë¯¸ì§€ íˆìŠ¤í† ë¦¬ì— ì¶”ê°€
            self.image_history.append(pixmap)

            image_label.setPixmap(pixmap.scaledToWidth(180))
            image_label.setCursor(Qt.PointingHandCursor)

            # í˜„ì¬ ì¸ë±ìŠ¤ë¥¼ ìº¡ì³í•´ì„œ ë„˜ê¹€
            index = len(self.image_history) - 1
            image_label.mousePressEvent = lambda e, idx=index: self.show_full_image(idx)

            image_layout.addWidget(image_label)
            layout.addWidget(image_container)

            file_label = QLabel(f"ğŸ’¾ {filename}")
            file_label.setStyleSheet("color: blue; text-decoration: underline;")
            file_label.setCursor(Qt.PointingHandCursor)
            file_label.mousePressEvent = lambda e: self.save_file(filename, data_b64)
            layout.addWidget(file_label)

        time_label = QLabel(time_str)
        time_label.setStyleSheet("color: gray; font-size: 10px;")
        layout.addWidget(time_label, alignment=Qt.AlignRight if from_self else Qt.AlignLeft)

        bubble_frame = QFrame()
        bubble_layout = QHBoxLayout(bubble_frame)
        bubble_layout.setContentsMargins(10, 4, 10, 4)

        if from_self:
            bubble_layout.addStretch()
            bubble_layout.addWidget(content_widget)
            bubble_layout.addWidget(profile_label)
        else:
            bubble_layout.addWidget(profile_label)
            bubble_layout.addWidget(content_widget)
            bubble_layout.addStretch()

        self.chat_layout.insertWidget(self.chat_layout.count() - 1, bubble_frame)
        QTimer.singleShot(10, self.scroll_to_bottom)

    # ì´ë¯¸ì§€ ëˆŒë €ì„ ë•Œ í¬ê²Œ í•´ì„œ ë¯¸ë¦¬ë³´ê¸°
    def show_full_image(self, index):
        self.current_image_index = index

        class ImageDialog(QDialog):
            def __init__(dialog_self):
                super().__init__(self)
                dialog_self.setWindowTitle("ì´ë¯¸ì§€ ë³´ê¸°")
                dialog_self.setFixedSize(600, 640)
                dialog_self.setModal(True)

                # ë ˆì´ì•„ì›ƒ ì„¤ì •
                dialog_self.layout = QVBoxLayout(dialog_self)
                dialog_self.layout.setContentsMargins(10, 10, 10, 10)
                dialog_self.layout.setSpacing(10)

                # ì´ë¯¸ì§€ ë¼ë²¨
                dialog_self.label = QLabel()
                dialog_self.label.setAlignment(Qt.AlignCenter)
                dialog_self.layout.addWidget(dialog_self.label)

                # ì¸ë±ìŠ¤ í‘œì‹œ ë¼ë²¨
                dialog_self.page_label = QLabel()
                dialog_self.page_label.setAlignment(Qt.AlignCenter)
                dialog_self.page_label.setStyleSheet("color: black; font-size: 12px;")
                dialog_self.layout.addWidget(dialog_self.page_label)

                dialog_self.update_image()

            def update_image(dialog_self):
                pixmap = self.image_history[self.current_image_index]
                dialog_self.label.setPixmap(pixmap.scaled(
                    580, 580, Qt.KeepAspectRatio, Qt.SmoothTransformation))

                # ì¸ë±ìŠ¤ ì •ë³´ í‘œì‹œ
                dialog_self.page_label.setText(
                    f"{self.current_image_index + 1} / {len(self.image_history)}"
                )

            def keyPressEvent(dialog_self, event):
                if event.key() == Qt.Key_Right and self.current_image_index < len(self.image_history) - 1:
                    self.current_image_index += 1
                    dialog_self.update_image()
                elif event.key() == Qt.Key_Left and self.current_image_index > 0:
                    self.current_image_index -= 1
                    dialog_self.update_image()
                elif event.key() == Qt.Key_Escape:
                    dialog_self.reject()

            def wheelEvent(dialog_self, event):
                delta = event.angleDelta().y()
                if delta < 0 and self.current_image_index < len(self.image_history) - 1:
                    self.current_image_index += 1
                    dialog_self.update_image()
                elif delta > 0 and self.current_image_index > 0:
                    self.current_image_index -= 1
                    dialog_self.update_image()

        dialog = ImageDialog()
        dialog.exec_()

    def save_file(self, filename, data_b64):
        save_path, _ = QFileDialog.getSaveFileName(self, "íŒŒì¼ ì €ì¥", filename)

        if not save_path:
            return

        _, ext = os.path.splitext(filename)
        if ext and not save_path.lower().endswith(ext):
            save_path += ext

        try:
            with open(save_path, "wb") as f:
                f.write(base64.b64decode(data_b64))
        except Exception as e:
            print(f"âŒ íŒŒì¼ ì €ì¥ ì‹¤íŒ¨: {e}")

    # ì„œë²„ì—ì„œ ë°›ì€ ìœ ì € ëª©ë¡ ì ìš©
    def update_user_list(self, users):
        self.user_list.clear()
        for user in users:
            if user != self.username:
                self.user_list.addItem(user)
        self.user_list_label.setText(f"ì ‘ì† ì¤‘: {', '.join(users)}")


    # ì±„íŒ…ë°© ê°œì„¤ í•¨ìˆ˜
    def open_private_chat(self, item):
        partner = item.text()
        chat_window = PrivateChatWindow(self.username, partner, self.websocket)
        chat_window.setWindowTitle(f"{self.username} â†” {partner}")
        chat_window.show()
        self.private_chats[partner] = chat_window


    """
    def scroll_to_bottom(self):
        self.scroll_area.verticalScrollBar().setValue(
            self.scroll_area.verticalScrollBar().maximum()
        )
    """
    # ê°œì„  ë²„ì „
    def scroll_to_bottom(self):
        scroll_bar = self.scroll_area.verticalScrollBar()
        if scroll_bar:
            scroll_bar.setValue(scroll_bar.maximum())

    # ìŠ¤í¬ë¡¤ í•¨ìˆ˜ ì¶”ê°€: êµ¬ë¶„ì„  ìœ„ì¹˜ë¡œ ì´ë™
    def scroll_to_separator(self):
        """
        ì´í›„ ìƒˆ ë©”ì‹œì§€ ë¼ë²¨ì´ ë³´ì´ë„ë¡ ìŠ¤í¬ë¡¤ì„ ì´ë™
        :return:
        """
        print("scroll_to_separator í˜¸ì¶œ")
        if hasattr(self, "separator_label") and self.separator_label is not None:
            print("ğŸ”½ êµ¬ë¶„ì„ ê¹Œì§€ ì´ë™ ì‹œë„")
            self.scroll_area.ensureWidgetVisible(self.separator_label, yMargin=20)
        else:
            print("âš ï¸ êµ¬ë¶„ì„ ì´ ì•„ì§ ì¡´ì¬í•˜ì§€ ì•ŠìŒ!")
    
class PrivateChatWindow(QDialog):
    def __init__(self, sender, receiver, websocket):
        super().__init__()
        self.sender = sender
        self.receiver = receiver
        self.websocket = websocket

        self.setWindowTitle(f"{self.sender} â†” {self.receiver}")
        self.resize(400, 300)

        self.chat_area = QTextBrowser()
        self.input = QLineEdit()
        self.send_button = QPushButton("ë³´ë‚´ê¸°")

        layout = QVBoxLayout()  # âœ… ìˆ˜ì§ ë ˆì´ì•„ì›ƒ ëª…í™•íˆ ì§€ì •
        layout.addWidget(self.chat_area)
        layout.addWidget(self.input)
        layout.addWidget(self.send_button)
        self.setLayout(layout)

        self.send_button.clicked.connect(self.send_private_message)
        self.input.returnPressed.connect(self.send_private_message)

    def send_private_message(self):
        msg = self.input.text().strip()
        if msg:
            packet = {
                "type": "private_room",
                "sender": self.sender,
                "receiver": self.receiver,
                "message": msg
            }
            asyncio.create_task(self.websocket.send(json.dumps(packet)))
            self.chat_area.append(f"ë‚˜: {msg}")
            self.input.clear()

    def receive_message(self, sender, message):  # âœ… ë©”ì„œë“œëª… ìˆ˜ì • (recieve â†’ receive)
        self.chat_area.append(f"{sender}: {message}")


def main():
    app = QApplication(sys.argv)
    loop = QEventLoop(app)
    asyncio.set_event_loop(loop)

    client = ChatClient()
    client.show()

    with loop:
        loop.create_task(client.connect())
        loop.run_forever()

if __name__ == "__main__":
    main()